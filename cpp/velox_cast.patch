From cdc02f08f14c79b96aafbff4fdf9008100021d22 Mon Sep 17 00:00:00 2001
From: "wuxueyang.wxy" <wuxueyang.wxy@alibaba-inc.com>
Date: Sat, 5 Aug 2023 01:05:30 +0800
Subject: [PATCH 1/2] Add rescale double utility function.

---
 velox/type/DecimalUtil.h         | 45 +++++++++++++++++
 1 files changed, 45 insertions(+)

diff --git a/velox/type/DecimalUtil.h b/velox/type/DecimalUtil.h
index dec802c0431..60c11ca8416 100644
--- a/velox/type/DecimalUtil.h
+++ b/velox/type/DecimalUtil.h
@@ -16,6 +16,7 @@

 #pragma once

+#include <folly/Conv.h>
 #include <string>
 #include "velox/common/base/CheckedArithmetic.h"
 #include "velox/common/base/Exceptions.h"
@@ -193,6 +194,50 @@ class DecimalUtil {
     return static_cast<TOutput>(rescaledValue);
   }

+  /// Rescale a double value to decimal value.
+  ///
+  /// Use `folly::tryTo` to convert a double value to int128_t or int64_t. It
+  /// returns an error when overflow occurs so that we could determine whether
+  /// an overflow occurs through checking the result.
+  ///
+  /// Normally, return the rescaled value. Otherwise, if the `toValue` overflows
+  /// the TOutput's limits or the `toValue` exceeds the precision's limits, it
+  /// will throw an exception.
+  template <typename TOutput>
+  inline static TOutput
+  rescaleDouble(double inputValue, const int toPrecision, const int toScale) {
+    VELOX_USER_CHECK(
+        std::isfinite(inputValue),
+        "Cannot cast DOUBLE '{}' to DECIMAL({},{})",
+        inputValue,
+        toPrecision,
+        toScale);
+
+    auto toValue =
+        inputValue * static_cast<double>(DecimalUtil::kPowersOfTen[toScale]);
+
+    TOutput rescaledValue;
+    bool isOverflow = !std::isfinite(toValue);
+    if (!isOverflow) {
+      auto result = folly::tryTo<TOutput>(std::round(toValue));
+      if (result.hasError()) {
+        isOverflow = true;
+      } else {
+        rescaledValue = result.value();
+      }
+    }
+
+    if (isOverflow || rescaledValue < -DecimalUtil::kPowersOfTen[toPrecision] ||
+        rescaledValue > DecimalUtil::kPowersOfTen[toPrecision]) {
+      VELOX_USER_FAIL(
+          "Cannot cast DOUBLE '{:f}' to DECIMAL({},{})",
+          inputValue,
+          toPrecision,
+          toScale);
+    }
+    return rescaledValue;
+  }
+
   template <typename R, typename A, typename B>
   inline static R divideWithRoundUp(
       R& r,

From 8ce863707131e7ae77cb1fb37ae5edda30795a58 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E6=9E=A2=E6=9C=A8?= <wuxueyang.wxy@alibaba-inc.com>
Date: Fri, 21 Jul 2023 15:26:00 +0800
Subject: [PATCH 2/2] Add support for casting Double to Decimal.

---
 velox/expression/CastExpr-inl.h            | 24 +++++++
 velox/expression/CastExpr.cpp              |  4 ++
 velox/expression/CastExpr.h                |  8 +++
 velox/expression/tests/CastExprTest.cpp    | 74 ++++++++++++++++++++++
 4 files changed, 134 insertions(+)

diff --git a/velox/expression/CastExpr-inl.h b/velox/expression/CastExpr-inl.h
index 6680243f643..ff05a400c24 100644
--- a/velox/expression/CastExpr-inl.h
+++ b/velox/expression/CastExpr-inl.h
@@ -206,6 +206,30 @@ void CastExpr::applyIntToDecimalCastKernel(
       });
 }

+template <typename TOutput>
+void CastExpr::applyDoubleToDecimal(
+    const SelectivityVector& rows,
+    const BaseVector& input,
+    exec::EvalCtx& context,
+    const TypePtr& toType,
+    VectorPtr& castResult) {
+  auto sourceVector = input.as<SimpleVector<double>>();
+  auto rawResults =
+      castResult->asUnchecked<FlatVector<TOutput>>()->mutableRawValues();
+  const auto toPrecisionScale = getDecimalPrecisionScale(*toType);
+  applyToSelectedNoThrowLocal(
+      context, rows, castResult, [&](vector_size_t row) {
+        if (sourceVector->isNullAt(row)) {
+          castResult->setNull(row, true);
+          return;
+        }
+        rawResults[row] = DecimalUtil::rescaleDouble<TOutput>(
+            sourceVector->valueAt(row),
+            toPrecisionScale.first,
+            toPrecisionScale.second);
+      });
+}
+
 template <typename FromNativeType, TypeKind ToKind>
 VectorPtr CastExpr::applyDecimalToFloatCast(
     const SelectivityVector& rows,
diff --git a/velox/expression/CastExpr.cpp b/velox/expression/CastExpr.cpp
index ac0a7e8203b..ea6b410ca94 100644
--- a/velox/expression/CastExpr.cpp
+++ b/velox/expression/CastExpr.cpp
@@ -457,6 +457,10 @@ VectorPtr CastExpr::applyDecimal(
       applyIntToDecimalCastKernel<int32_t, toDecimalType>(
           rows, input, context, toType, castResult);
       break;
+    case TypeKind::DOUBLE:
+      applyDoubleToDecimal<toDecimalType>(
+          rows, input, context, toType, castResult);
+      break;
     case TypeKind::BIGINT: {
       if (fromType->isShortDecimal()) {
         applyDecimalCastKernel<int64_t, toDecimalType>(
diff --git a/velox/expression/CastExpr.h b/velox/expression/CastExpr.h
index 1572a2e014c..513e3367a57 100644
--- a/velox/expression/CastExpr.h
+++ b/velox/expression/CastExpr.h
@@ -211,6 +211,14 @@ class CastExpr : public SpecialForm {
       const TypePtr& toType,
       VectorPtr& castResult);

+  template <typename TOutput>
+  void applyDoubleToDecimal(
+      const SelectivityVector& rows,
+      const BaseVector& input,
+      exec::EvalCtx& context,
+      const TypePtr& toType,
+      VectorPtr& castResult);
+
   template <typename FromNativeType, TypeKind ToKind>
   VectorPtr applyDecimalToFloatCast(
       const SelectivityVector& rows,
diff --git a/velox/expression/tests/CastExprTest.cpp b/velox/expression/tests/CastExprTest.cpp
index d5cf922916e..57c1c2dc362 100644
--- a/velox/expression/tests/CastExprTest.cpp
+++ b/velox/expression/tests/CastExprTest.cpp
@@ -1476,6 +1476,80 @@ TEST_F(CastExprTest, integerToDecimal) {
   testIntToDecimalCasts<int64_t>();
 }

+TEST_F(CastExprTest, doubleToDecimal) {
+  // Double to short decimal.
+  auto input =
+      makeFlatVector<double>({-3333.03, -2222.02, -1.0, 0.00, 100, 99999.99});
+  testComplexCast(
+      "c0",
+      input,
+      makeFlatVector<int64_t>(
+          {-33'330'300, -22'220'200, -10'000, 0, 1'000'000, 999'999'900},
+          DECIMAL(10, 4)));
+
+  // Double to long decimal.
+  testComplexCast(
+      "c0",
+      input,
+      makeFlatVector<int128_t>(
+          {-33'330'300'000'000,
+           -22'220'200'000'000,
+           -10'000'000'000,
+           0,
+           1'000'000'000'000,
+           999'999'900'000'000},
+          DECIMAL(20, 10)));
+  testComplexCast(
+      "c0",
+      input,
+      makeFlatVector<int128_t>(
+          {-33'330, -22'220, -10, 0, 1'000, 1'000'000}, DECIMAL(20, 1)));
+
+  auto checkThrowError = [this](double value, TypePtr& type) {
+    auto trivialResult = type->isShortDecimal()
+        ? makeConstant<int64_t>(0, 1, type)
+        : makeConstant<int128_t>(0, 1, type);
+    VELOX_ASSERT_THROW(
+        testComplexCast("c0", makeConstant<double>(value, 1), trivialResult),
+        fmt::format(
+            "Cannot cast DOUBLE '{:f}' to {}", value, type->toString()));
+  };
+
+  auto numberBiggerThanInt64Max = static_cast<double>(
+      static_cast<int128_t>(std::numeric_limits<int64_t>::max()) + 1);
+  auto numberSmallerThanInt64Min = static_cast<double>(
+      static_cast<int128_t>(std::numeric_limits<int64_t>::min()) - 1);
+  auto decimalTypePrecision10Scale2 = DECIMAL(10, 2);
+
+  // Expected failures.
+  checkThrowError(9999999999999999999999.99, decimalTypePrecision10Scale2);
+  checkThrowError(numberBiggerThanInt64Max, decimalTypePrecision10Scale2);
+  checkThrowError(numberSmallerThanInt64Min, decimalTypePrecision10Scale2);
+
+  auto numberBiggerThanDecimal20 =
+      static_cast<double>(DecimalUtil::kLongDecimalMax);
+  auto numberSmallerThanDecimal20 =
+      static_cast<double>(DecimalUtil::kLongDecimalMin);
+  auto decimalTypePrecision20Scale2 = DECIMAL(20, 2);
+
+  checkThrowError(numberBiggerThanDecimal20, decimalTypePrecision20Scale2);
+  checkThrowError(numberSmallerThanDecimal20, decimalTypePrecision20Scale2);
+
+  double inf = INFINITY;
+  double nan = NAN;
+  auto doubleMax = std::numeric_limits<double>::max();
+  auto doubleMin = std::numeric_limits<double>::min();
+  auto decimalTypePrecision38Scale2 = DECIMAL(38, 2);
+
+  checkThrowError(inf, decimalTypePrecision38Scale2);
+  checkThrowError(nan, decimalTypePrecision38Scale2);
+  checkThrowError(doubleMax, decimalTypePrecision38Scale2);
+  testComplexCast(
+      "c0",
+      makeConstant<double>(doubleMin, 1),
+      makeConstant<int128_t>(0, 1, decimalTypePrecision38Scale2));
+}
+
 TEST_F(CastExprTest, castInTry) {
   // Test try(cast(array(varchar) as array(bigint))) whose input vector is
   // wrapped in dictinary encoding. The row of ["2a"] should trigger an error
